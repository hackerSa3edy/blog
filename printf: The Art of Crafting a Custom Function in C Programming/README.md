# printf: The Art of Crafting a Custom Function in C Programming
![Image generated By [Bing Image Creator](https://www.bing.com/images/create?FORM=GDPGLP)](./printf_cover.png)

##### Image generated By [Bing Image Creator](https://www.bing.com/images/create?FORM=GDPGLP)

In the world of programming, there are few functions as fundamental and ubiquitous as `printf`. If you've ever written code in the C programming language, chances are you've encountered this powerful and versatile function. `printf` stands as a testament to C's elegance and simplicity, enabling programmers to display text and formatted data to the console with unparalleled precision and control. However, while using `printf` is second nature to many developers, have you ever stopped to wonder how this marvel of functionality actually works under the hood?

In this technical blog post, we will embark on a journey into the inner workings of `printf`, uncovering its vital role in C programming, and ultimately, delving into the process of crafting your very own custom `printf` function. As we delve deeper into the importance of `printf`, you'll discover how understanding its core mechanisms can not only enhance your comprehension of C but also empower you to create tailored formatting solutions tailored to your unique coding challenges. So, fasten your seatbelts, and let's embark on a fascinating exploration of the inner workings of `printf`, illuminating the path to writing your own custom implementation.

![by [elliosho](https://tenor.com/users/elliosho) on [tenor](https://tenor.com/view/do-this-gif-18382134).](./do-this.gif)

##### by [elliosho](https://tenor.com/users/elliosho) on [tenor](https://tenor.com/view/do-this-gif-18382134).

---

> 💡 **For this project, it is anticipated that you possess a detailed understanding of the following subjects:**
> - Memory allocation
> - Variadic functions
> - Function pointers
> - Structures and typedef
>

## **The Value of Writing Your Own `printf`.**

For students venturing into the world of C programming, the process of learning and mastering the intricacies of this language can often feel like navigating a dense and mysterious forest. C, with its minimalistic syntax and emphasis on control and efficiency, is renowned for its power and versatility. However, these very qualities can make it a formidable challenge, especially for beginners. Amidst the journey of learning C, one may wonder, “Why should I bother writing my own `printf` function when there's a perfectly functional built-in version available?"

The answer to this question lies in the profound educational value that comes from crafting your own `printf`. Here are several compelling reasons why students embarking on their C programming journey should consider taking on this task:

### **1. Deeper Understanding of C Fundamentals**

Writing your own `printf` forces you to dissect and understand the fundamental principles of C at a granular level. You'll need to grapple with topics like data types, memory allocation, pointers, and the intricacies of variadic functions. This process not only strengthens your comprehension but also equips you with essential skills that will prove invaluable as you tackle more complex programming challenges.

### **2. Enhanced Debugging and Troubleshooting Skills**

Debugging is an integral part of a programmer’s life, and when you write your own `printf`, you're likely to encounter a fair share of bugs and issues. Solving these problems sharpens your analytical thinking and debugging skills. You'll gain firsthand experience in diagnosing issues, tracing code execution, and fixing errors—an invaluable skill set that transcends `printf` itself.

### **3. Tailored Formatting Solutions**

One size doesn’t fit all in programming. While the standard `printf` is versatile, you might encounter situations where you need custom formatting or specialized output. Crafting your own `printf` empowers you to create formatting solutions tailored to your specific project requirements. This flexibility can be a game-changer when you're working on projects with unique output needs.

### **4. Confidence in Low-Level Manipulation**

Writing a `printf` function involves low-level memory manipulation, such as working with pointers and managing data buffers. Mastering these skills instills confidence in handling memory at a granular level—an essential ability when working on performance-critical applications or interfacing with hardware.

### **5. A Sense of Accomplishment**

Completing the task of writing your own `printf` can be a source of immense pride and accomplishment. It's a tangible demonstration of your growth as a programmer and serves as a reminder that with persistence and effort, you can conquer even the most challenging programming tasks.

In essence, writing your own `printf` function isn't merely an exercise in redundancy; it's a profound learning experience that equips you with a deep understanding of C, sharpens your debugging skills, and empowers you to craft solutions uniquely tailored to your programming needs. So, as you embark on this journey to understand and create your `printf`, remember that the knowledge and skills gained along the way are as valuable as the destination itself.



## **Basic Usage of `printf` in C Programming**

Before diving into the intricacies of creating your custom `printf` function, it's crucial to establish a solid foundation by understanding how to use the standard `printf` in C. `printf` is a cornerstone of C programming, allowing you to output data and text to the console, making it an indispensable tool for both beginners and seasoned developers. Here's a breakdown of the basic usage of `printf`:

### **1. Printing Literal Text**

The simplest use of `printf` is to print literal text to the console. To do this, you enclose the text within double quotation marks. For example:

```c
printf("Hello, world!\n");
```

In this case, the `printf` function will output "Hello, world!" followed by a newline character (`\n`) to move to the next line.

### **2. Formatting Variables**

`printf` truly shines when it comes to formatting and displaying variables. You can insert variables into your output string by using format specifiers that match the data type of the variable. Common format specifiers include:

- `%d` for integers
- `%f` for floating-point numbers
- `%c` for characters
- `%s` for strings

For example, to print an integer and a floating-point number, you can use:

```c
int age = 25, returns = 0;
float height = 1.75;

returns = printf("Age: %d, Height: %.2f meters\n", age, height);
printf("printf returns: %d\n", returns);
```

The output should be:

```
Age: 25, Height: 1.75 meters
printf returns: 29
```

In this code snippet, `%d` is used for the integer variable `age`, and `%f` is used for the floating-point variable `height`. The `.2` in `%.2f` specifies that the floating-point number should be displayed with two decimal places.

> 💡 It’s important to note that printf provides a return value representing the number of characters it has printed. In this specific case, when you use printf with the format string “`Age: %d, Height: %.2f meters\n`” and substitute the specifiers with their corresponding values, `printf` returns 29, indicating that it has successfully printed 29 characters from the formatted string.
>


### **3. Escape Sequences**

Escape sequences are special characters that begin with a backslash (`\`) and have special meanings. They allow you to control the output format. Common escape sequences include:

- `\n`: Newline
- `\t`: Tab
- `\\`: Backslash
- `\"`: Double quote
- `\'`: Single quote

For example, to format text with a newline and a tab:

```c
printf("This is a line of text.\n\tThis is indented.\n");
```

### **4. Multiple Variables in a Single `printf` Statement**

You can include multiple variables and literals in a single `printf` statement by separating them with commas:

```c
int apples = 5, oranges = 3;

printf("I have %d apples and %d oranges.\n", apples, oranges);
```

This code will output “I have 5 apples and 3 oranges.”


## **Data Types and Format Specifiers in `printf`**

One of the key aspects of mastering the `printf` function in C programming is understanding the relationship between data types and format specifiers. Format specifiers are placeholders used within the `printf` function to indicate the type of data that should be displayed. Properly matching format specifiers with the corresponding data types is essential to ensure that your output is accurate and well-formatted. Let's delve deeper into this critical concept:

### **1. The Importance of Format Specifiers**

Format specifiers serve as directives to `printf`, informing it how to interpret and display the data you provide. Using the wrong format specifier can lead to unexpected and erroneous output. Therefore, it's crucial to know which format specifier corresponds to each data type you intend to print.

### **2. Common Data Types and Format Specifiers**

Here’s a breakdown of some common C data types and their corresponding format specifiers:

**Integers (`int`, `short`, `long`, etc.):**

- `%d` or `%i`: Print as a decimal integer.
- `%u`: Print as an unsigned decimal integer.
- `%x` or `%X`: Print as a hexadecimal integer (lowercase or uppercase).
- `%o`: Print as an octal integer.

**Floating-Point Numbers (`float`, `double`, `long double`):**

- `%f`: Print as a floating-point number.
- `%e` or `%E`: Print in scientific notation (lowercase or uppercase).
- `%g` or `%G`: Print in the shorter of `%f` or `%e` format (lowercase or uppercase).

**Characters (`char`):**

- `%c`: Print as a character.

**Strings (`char` arrays or pointers):**

- `%s`: Print as a null-terminated string.

**Pointers (`void*` or specific data type pointers):**

- `%p`: Print as a pointer address in hexadecimal.


## **Implementing your custom `printf`.**

> Note: All the coming flowcharts based on my Implementation of custom printf.
>

![Implementation flowchart for printf. Credits: Abdelrahman Mohamed](./printf_core_functions.png)

##### Implementation flowchart for printf. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).

Implementing your own version of `printf` is a rewarding and educational endeavor that requires a deep understanding of C's variable argument handling and string manipulation capabilities. Here, we'll break down the process of creating a simplified `printf` function step by step, focusing on the essential components:

### **1. Variadic Function Signature**

To emulate the variable argument behavior of `printf`, your custom `printf` function must have a variadic function signature. In C, this is achieved using the `stdarg.h` header and the `va_list` data type. Here's how you declare your custom `printf` function:

```c
#include <stdarg.h>

int _printf(const char* format, ...);
```

### **2. Parsing the Format String**

The first task is to parse the format string and process each specifier. This involves iterating through the format string character by character and identifying format specifiers (e.g., `%d`, `%s`, `%f`) when encountered. You can use a loop to achieve this.

### **3. Handling Format Specifiers**

For each format specifier, your `printf` implementation needs to:

- Identify the specifier type (e.g., integer, floating-point, character, string).
- Extract the corresponding argument from the variable argument list.
- Convert the argument to its string representation according to the specifier.
- Print the converted string.

For example, when encountering `%d`, you would use `va_arg` to retrieve an `int` from the variable argument list and then convert it to a string. And that what we will discuss next.

### **4. Handling the common Edge Cases**

Let's delve into these edge cases and explore how to handle them within your custom `printf` implementation:

#### **I. Format Argument is `NULL`**

**Edge Case:** When the format argument itself is `NULL`, attempting to parse it as a format string will lead to segmentation fault.

**Handling:** Add a check at the beginning of your custom`_printf` function to handle this case explicitly. in case of the standard `printf`function, it returns `-1`.

```c
#include "main.h"

int main(void)
{
        int returns = 0;

        returns = printf(NULL);
        printf("printf returns: %d\n", returns);

        returns = _printf(NULL);
        printf("_printf returns: %d\n", returns);

        return (0);
}
```

The output should be:

```
printf returns: -1
_printf returns: -1
```

#### **II. Unknown Format Specifier**

**Edge Case:** If a format specifier not recognized by your custom `printf` is encountered, it should be handled gracefully to prevent unexpected behavior.

**Handling:** You can choose to print an error message or treat the unknown specifier as a regular character.

> Your custom printf should works like the standard printf.
>

```c
#include "main.h"

int main(void)
{
        int returns = 0;

        returns = printf("hello %, how are you\n");
        printf("printf returns: %d\n", returns);

        returns = _printf("hello %, how are you\n");
        printf("_printf returns: %d\n", returns);

        return (0);
}
```

The output should be:

```
hello %, how are you
printf returns: 21
hello %, how are you
_printf returns: 21
```

here the `,` character is not a valid format specifier.

#### **III. `%` Symbol at the End**

**Edge Case:** When the `%` symbol is the last character in the format string (e.g., `"This is a percent sign: %"`) and is not followed by a format specifier, this is a special case.

**Handling:** Like the standard `printf`, don’t print it and return `-1`.

```c
#include "main.h"

int main(void)
{
        int returns = 0;

        returns = printf("hello, how are you\n%");
        printf("printf returns: %d\n", returns);

        returns = _printf("hello, how are you\n%");
        printf("_printf returns: %d\n", returns);

        return (0);
}
```

The output should be:

```
hello, how are you
printf returns: -1
hello, how are you
_printf returns: -1
```

#### **IV. Less Format Specifiers Than Arguments**

**Edge Case:** If there are fewer format specifiers in the format string than there are corresponding arguments.

**Handling:** Simply the standard `printf` ignores them.

#### **V. Valid Format Specifiers**

**Edge Case:** When a valid format specifier is encountered, it should be properly processed and replaced with the corresponding argument.

**Handling:** Implement a switch statement or a function pointer that takes the format specifier and returns the corresponding function which in turn extracts the corresponding argument using `va_arg` and formats it accordingly before printing it to the output.

![pointer function that takes a char and returns a pointer to a function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).](./get_op_func.png)

##### pointer function that takes a char and returns a pointer to a function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).

Thoroughly addressing these exceptional situations within your custom `printf` implementation enables you to develop a printf function that is robust and adaptable. This ensures it can effectively manage diverse scenarios and input conditions, guaranteeing consistent and dependable output. You can achieve this by closely examining the behavior of your custom `printf` in comparison to the standard `printf` to identify and rectify any discrepancies.

### **5. Printing the Output**

With each specifier processed and converted to its string representation, concatenate these strings to build the final output. You can use a dynamic memory allocation method, such as `malloc`, to manage the output buffer.

### **6. Clean Up**

Release any dynamically allocated memory and perform other cleanup tasks before the function exits to prevent memory leaks.

Please note that this is a simplified example for educational purposes. A full-featured `printf` implementation would need to handle a wider range of format specifiers, flags, width, and precision, as well as various edge cases and modifiers. The above code serves as a starting point to better understand the core principles of building your custom `printf`.


## **In-Depth Exploration of Specifiers, Flags, and Custom Specifiers in `printf`**

In our quest to create a custom `printf` function that mirrors the functionality of the standard `printf`, let's delve into the implementation details of various specifiers, flags, and even some custom extensions. While we won't cover every possible specifier and flag available in `printf`, we'll discuss a selection of commonly used ones, along with unique custom specifiers.

We use the function `_putchar` to write the specified character to the standard output.

```c
#include "main.h"

/**
 * _putchar - function that print / write char
 *
 * @c: the arg. present the char to print
 *
 * Return: 1 on success
 */

int _putchar(char c)
{
        return (write(1, &c, 1));
}
```

### **Specifiers**

#### **`%c` - Character**

![Implementation flowchart for print_char function. Credits: [Tahani Habib](https://github.com/Tahani-Saber).](./print_char.png)

##### Implementation flowchart for print_char function. Credits: [Tahani Habib](https://github.com/Tahani-Saber).

The `%c` specifier is used to print a single character. It is relatively straightforward, but an edge case to consider is when the character is a string or NULL. In both cases, you don’t have to write aditional code to handle them. When NULL is passed, the compiler typically ignores the specifier and continues printing the remaining string. However, when passing a string to it, it may print unexpected characters, which is consistent with the behavior of the standard printf.

#### **`%s` - String**

![Implementation flowchart for print_str function. Credits: [Tahani Habib](https://github.com/Tahani-Saber).](./print_str.png)

##### Implementation flowchart for print_str function. Credits: [Tahani Habib](https://github.com/Tahani-Saber).

The `%s` specifier prints a null-terminated string. An edge case is when the string is `NULL`, requiring special handling to prevent segmentation faults; the standard `printf` prints `(null)`.

```c
#include "main.h"

int main(void)
{
        int returns = 0;

        returns = printf("hello %s, how are you\n", NULL);
        printf("printf returns: %d\n", returns);

        returns = _printf("hello %s, how are you\n", NULL);
        printf("_printf returns: %d\n", returns);

        return (0);
}
```

The output should be

```
hello (null), how are you
printf returns: 26
hello (null), how are you
_printf returns: 26
```

#### **`%%` - Percent**

The `%%` specifier is used to print a literal percent sign (`%`). There are no edge cases to consider; it's a straightforward specifier, when it is found, we write it to the standard output.

#### **`%d`, `%i`, `%u`, `%x`, `%X`, `%o` - Numeric Specifiers**

These specifiers are used for printing various numeric types (integers and unsigned integers) in decimal, hexadecimal (lowercase and uppercase), and octal formats. Edge cases include handling negative numbers, zero-padding, and ensuring consistent formatting.

#### **`%p` - Pointer**

![Implementation flowchart for print_ptr function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).](./print_ptr.png)

##### Implementation flowchart for print_ptr function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).

The `%p` specifier prints a pointer address in hexadecimal. It's crucial to handle this specifier correctly, considering variations in pointer size on different architectures and managing null pointers.

### **Custom Specifiers**

#### **`%b` - Binary**

![Implementation flowchart for print_bin function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).](./print_bin.png)

##### Implementation flowchart for print_bin function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).

A custom `%b` specifier prints an integer in binary format. To implement this, you'll need to convert the integer to its binary representation.

- the `convert` function here converts the decimal number to its equivalent in binary (base 2) and print it.

#### **`%S` - Hexadecimal Non-Printable Characters**

![Implementation flowchart for print_STR function. Credits: [Tahani Habib](https://github.com/Tahani-Saber).](./print_STR.png)

##### Implementation flowchart for print_STR function. Credits: [Tahani Habib](https://github.com/Tahani-Saber).

This custom specifier extends `%s` by printing non-printable characters in hexadecimal format. It involves checking each character in the string for printability and converting non-printable characters to their hexadecimal representations.

#### **`%r` - Reverse String**

The `%r` specifier reverses the order of characters in a string. Implementing this requires iterating through the string, reversing its content, or printing each character in the string from the end of the string to the beginning.

#### **`%R` - ROT13 Encoding**

![Implementation flowchart for print_rot13 function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).](./print_rot13.png)

##### Implementation flowchart for print_rot13 function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).

This custom specifier applies the ROT13 encoding to a string, which is a simple letter substitution cipher. Each letter is shifted 13 places down the alphabet. Consider both uppercase and lowercase letters.

### **Flags**

![Implementation flowchart for get_flags function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).](./get_flags.png)

##### Implementation flowchart for get_flags function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).

#### **`#` - Alternate Form**

The `#` flag is used with `%x`, `%X`, `%o`, and `%a` specifiers. It specifies that the result should include a prefix (e.g., `0x` for hexadecimal numbers) for alternative representations.

![Implementation flowchart for print_octal function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).](./print_octal.png)

##### Implementation flowchart for print_octal function. Credits: [Abdelrahman Mohamed](https://github.com/hackerSa3edy).

#### **`' '` (Space) - Space-Padding**

The space flag in the `printf` function in C is used to specify that, if the value being printed is positive, it should be preceded by a space character. This flag is typically used with the `%d`, `%i`, and `%f` format specifiers for integers and floating-point numbers.

Here’s how the space flag works with different format specifiers:

1. `%d` and `%i` for integers:
- If the integer is positive, it is normally printed without any sign.
- If the integer is negative, it is printed with a minus sign.
- When the space flag is used, if the integer is positive, it is printed with a leading space character.

```c
#include "main.h"

int main(void)
{
        int returns = 0;

        returns = printf("hello % i, how are you\n", -72);
        printf("printf returns: %d\n", returns);

        returns = _printf("hello % i, how are you\n", 72);
        printf("_printf returns: %d\n", returns);

        return (0);
}
```

So, the output should be as the following:

```
hello -72, how are you
printf returns: 23
hello  72, how are you
_printf returns: 23
```

#### **`+` - Sign Flag**

The `+` flag specifies that a sign character (either `+` or `-`) should be included for positive numbers when using `%d`, `%i`, `%f`, `%e`, and `%g` specifiers.

```c
#include "main.h"

int main(void)
{
        int returns = 0;

        returns = printf("hello %+i, how are you\n", 72);
        printf("printf returns: %d\n", returns);

        returns = _printf("hello %+i, how are you\n", 72);
        printf("_printf returns: %d\n", returns);

        return (0);
}
```

So, the output should be as the following:

```
hello +72, how are you
printf returns: 23
hello +72, how are you
_printf returns: 23
```

Implementing these specifiers, custom extensions, and flags requires careful consideration of edge cases to ensure the custom `printf` function behaves correctly and consistently. By addressing these cases, you can create a powerful and versatile `printf` implementation that meets the needs of your specific programming tasks.


## **Conclusion**

Custom `printf`-like functions offer tremendous flexibility and customization possibilities for C programmers. However, to harness their power effectively, it's crucial to navigate the edge cases that come with crafting format specifiers. By addressing challenges related to special characters, variable arguments, format specifier length, precision and width, and error handling, you can create custom `printf` functions that not only meet your specific needs but also adhere to best practices in C programming. As you embark on building your custom format specifiers, keep these considerations in mind to ensure your functions are robust, versatile, and reliable.


## **📘Resources**

- Every flowchart both mentioned and unmentioned in the article: [blog/printf (github.com)](https://github.com/hackerSa3edy/blog/tree/master/printf:%20The%20Art%20of%20Crafting%20a%20Custom%20Function%20in%20C%20Programming)
- Custom printf: [Tahani-Saber/printf (github.com)](https://github.com/Tahani-Saber/printf)
- [How To Write My Own Printf() In C? • Scientyfic World](https://scientyficworld.org/how-to-write-my-own-printf-in-c/)
- [printf format identifiers. (polytechnique.fr)](https://www.lix.polytechnique.fr/~liberti/public/computing/prog/c/C/FUNCTIONS/format.html)
- [libc — How to write my own printf() in C? — Stack Overflow](https://stackoverflow.com/questions/1735236/how-to-write-my-own-printf-in-c)
- [printf project (notion.site)](https://www.notion.so/d4808647995045d7ad0c9716e0b287be?pvs=21)
- [(PDF) Secrets of “printf “ | Thomas Samuel — Academia.edu](https://www.academia.edu/10297206/Secrets_of_printf_)


## Let’s Connect and Grow Together 🚀🌱

Thank you for taking the time to read this article on mastering the `printf` function in C programming. I hope you found the insights and tips valuable for your coding journey. 📚💡

Your thoughts, questions, and experiences matter to me. I’d love to hear from you and continue the conversation. Feel free to share your thoughts, ask questions, or provide feedback in the comments below. Your insights can inspire us all to learn and grow together. 💬🤝

- [Abdelrahman Mohamed | Portfolio](https://www.notion.so/Abdelrahman-Mohamed-fb5a61c08f5548eca17949b890b8f379?pvs=21)
- [Abdelrahman Mohamed | LinkedIn](https://www.linkedin.com/in/abdelrahmanm0/)
- [Abdelrahman Mohamed | X](https://twitter.com/HackerSa3edy)
- [Abdelrahman Mohamed | GitHub](https://github.com/hackerSa3edy)
